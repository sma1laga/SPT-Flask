{% extends "base.html" %}
{% block content %}
<div class="container wide-container conditional-distributions-layout">
  <div class="page-header">
    <div>
      <h1>Conditional Distributions</h1>
      <p>
        Explore how conditioning on an interval \(A = [A_{\min}, A_{\max}]\) reshapes a distribution's PDF and CDF.
        Choose one of the supported models (uniform, normal, exponential), adjust its parameters, and see both
        the unconditioned and conditioned curves side by side.
      </p>
    </div>
    <div class="chip-row">
      <div class="pill"><i class="fa fa-bolt"></i>Interactive demo</div>
      <div class="pill pill-subtle"><i class="fa fa-line-chart"></i>Real-time updates</div>
    </div>
  </div>



  <div class="demo-grid">
    <div class="control-card">
      <div class="pill"><i class="fa fa-sliders"></i>Controls</div>
      <div class="kv-row">
        <label for="distribution">Distribution</label>
        <select id="distribution">
          <option value="uniform">Uniform</option>
          <option value="normal">Normal</option>
          <option value="exponential">Exponential</option>
        </select>
        <div></div>
      </div>
      <div id="controls" class="control-grid"></div>
      <p class="inline-note">Adjusting any slider recomputes the curves immediately.</p>
      <div id="error" class="error" aria-live="polite"></div>
    </div>

    <div class="plot-card">
      <div class="plot-header">
        <div class="pill"><i class="fa fa-area-chart"></i>PDF &amp; CDF</div>
        <div class="plot-meta">
          <div id="probability" class="inline-note"></div>
        </div>
      </div>
      <div id="plot-title" class="latex-title" aria-live="polite"></div>
      <div id="subplot-labels" class="subplot-labels" aria-hidden="true"></div>
      <div id="plot" class="plot-wrapper"></div>
    </div>

    <div class="summary-card" aria-live="polite">
      <div class="pill pill-subtle"><i class="fa fa-table"></i>Distribution Summary</div>
      <div class="summary-strip">
        <div class="summary-item">
          <div class="summary-label">Distribution</div>
          <div id="dist-label" class="summary-value accent">Uniform</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Support</div>
          <div id="support-label" class="summary-value">[ -5.00 , 5.00 ]</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Condition Interval</div>
          <div id="interval-label" class="summary-value">[ -1.00 , 1.00 ]</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Probability Mass</div>
          <div id="prob-chip" class="summary-value strong">—</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script>
  const defaults = {{ defaults | tojson }};
  const controlsEl = document.getElementById('controls');
  const plotEl = document.getElementById('plot');
  const latexTitleEl = document.getElementById('plot-title');
  const latexLabelsEl = document.getElementById('subplot-labels');
  const errorEl = document.getElementById('error');
  const probEl = document.getElementById('probability');
  const latexQueue = new Set();
  let mathJaxInterval = null;
  function typesetLatex(blocks) {
    blocks.filter(Boolean).forEach((blk) => latexQueue.add(blk));

    const attempt = () => {
      if (window.MathJax?.typesetPromise) {
        const items = Array.from(latexQueue);
        latexQueue.clear();
        window.MathJax.typesetPromise(items).catch((err) => console.error('MathJax typeset error', err));
        if (mathJaxInterval) {
          clearInterval(mathJaxInterval);
          mathJaxInterval = null;
        }
        return true;
      }
      return false;
    };

    if (!attempt() && !mathJaxInterval) {
      mathJaxInterval = setInterval(attempt, 250);
    }
  }

  const CONFIG = {
    uniform: {
      params: [
        { key: 'x_max', label: 'X_max', min: 5, max: 9.9, step: 0.1, value: defaults.x_max },
        { key: 'x_min', label: 'X_min', min: -9.9, max: -5, step: 0.1, value: defaults.x_min },
        { key: 'a_max', label: 'A_max', min: 0, max: 5, step: 0.1, value: defaults.a_max },
        { key: 'a_min', label: 'A_min', min: -5, max: -0.1, step: 0.1, value: defaults.a_min },
      ],
      description: 'Uniform on [X_min, X_max]'
    },
    normal: {
      params: [
        { key: 'mean', label: 'Mean', min: -10, max: 10, step: 0.1, value: defaults.mean },
        { key: 'variance', label: 'Variance', min: 0.1, max: 10, step: 0.1, value: defaults.variance },
        { key: 'a_max', label: 'A_max', min: 0, max: 10, step: 0.1, value: 1 },
        { key: 'a_min', label: 'A_min', min: -10, max: -0.1, step: 0.1, value: -1 },
      ],
      description: 'Normal with mean and variance'
    },
    exponential: {
      params: [
        { key: 'lambda', label: 'Lambda', min: 0.01, max: 1, step: 0.01, value: defaults.lambda },
        { key: 'a_max', label: 'A_max', min: 10, max: 20, step: 0.1, value: 15 },
        { key: 'a_min', label: 'A_min', min: 0, max: 9.9, step: 0.1, value: 5 },
      ],
      description: 'Exponential with rate λ (support ≥ 0)'
    }
  };

  function buildControlRow({ key, label, min, max, step, value }) {
    const row = document.createElement('div');
    row.className = 'kv-row';
    row.innerHTML = `
      <label for="${key}">${label}</label>
      <input type="range" id="${key}" min="${min}" max="${max}" step="${step}" value="${value}">
      <span id="${key}_val">${value}</span>
    `;
    return row;
  }

  function renderControls(dist) {
    controlsEl.innerHTML = '';
    const cfg = CONFIG[dist];
    cfg.params.forEach(p => {
      const row = buildControlRow(p);
      controlsEl.appendChild(row);
    });
    if (cfg.description) {
      const note = document.createElement('div');
      note.className = 'inline-note';
      note.textContent = cfg.description + ' | A = [A_min, A_max]';
      controlsEl.appendChild(note);
    }
    attachListeners();
    updateSummary();

  }

  function payload() {
    const dist = document.getElementById('distribution').value;
    const cfg = CONFIG[dist];
    const data = { distribution: dist };
    cfg.params.forEach(p => {
      const el = document.getElementById(p.key);
      data[p.key] = parseFloat(el.value);
    });
    return data;
  }

  function syncLabels() {
    document.querySelectorAll('#controls input[type=range]').forEach(inp => {
      const out = document.getElementById(`${inp.id}_val`);
      if (out) { out.textContent = parseFloat(inp.value).toFixed(2); }
    });
  }

  function toTitleCase(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  function getVal(id) {
    const el = document.getElementById(id);
    return el ? parseFloat(el.value) : NaN;
  }

  function updateSummary(data) {
    const dist = document.getElementById('distribution').value;
    const distLabel = document.getElementById('dist-label');
    const supportLabel = document.getElementById('support-label');
    const intervalLabel = document.getElementById('interval-label');
    const probChip = document.getElementById('prob-chip');

    if (distLabel) { distLabel.textContent = toTitleCase(dist); }

    const aMin = getVal('a_min');
    const aMax = getVal('a_max');
    if (intervalLabel && !Number.isNaN(aMin) && !Number.isNaN(aMax)) {
      intervalLabel.textContent = `[ ${aMin.toFixed(2)} , ${aMax.toFixed(2)} ]`;
    }

    let supportText = '—';
    if (dist === 'uniform') {
      supportText = `[ ${getVal('x_min').toFixed(2)} , ${getVal('x_max').toFixed(2)} ]`;
    } else if (dist === 'normal') {
      supportText = '\u211d (all real numbers)';
    } else if (dist === 'exponential') {
      supportText = '[ 0 , \u221e )';
    }
    if (supportLabel) { supportLabel.textContent = supportText; }

    if (probChip) {
      if (typeof data?.condition_prob === 'number') {
        probChip.textContent = `P(A) = ${(Math.round(data.condition_prob * 1000) / 1000).toFixed(3)}`;
      } else {
        probChip.textContent = '—';
      }
    }
  }

  async function recompute() {
    errorEl.textContent = '';
    probEl.textContent = '';
    syncLabels();
    updateSummary();
    try {
      const res = await fetch('./compute', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload())
      });
      const data = await res.json();
      if (data.error) {
        errorEl.textContent = data.error;
        return;
      }
      renderPlot(data);
      if (typeof data.condition_prob !== 'undefined') {
        const p = Math.round(data.condition_prob * 1000) / 1000;
        probEl.textContent = `P(A) = ${p}`;
      }
      updateSummary(data);
    } catch (err) {
      console.error(err);
      errorEl.textContent = err;
    }
  }

  function renderPlot(data) {
    const { x, pdf, cdf, cond_pdf, cond_cdf, a_min, a_max, title, title_latex } = data;

    const mask = x.map(v => v >= a_min && v <= a_max);
    const highlightX = x.map((v, i) => (mask[i] ? v : null));
    const highlightPDF = pdf.map((v, i) => (mask[i] ? v : null));
    const highlightCDF = cdf.map((v, i) => (mask[i] ? v : null));

    const traces = [
      { x, y: cdf, mode: 'lines', name: 'F_X(x)', line: { color: '#2563eb', width: 3 }, xaxis: 'x', yaxis: 'y' },
      { x: highlightX, y: highlightCDF, mode: 'lines', name: 'A interval', fill: 'tozeroy', line: { color: 'rgba(239,68,68,0.7)' }, xaxis: 'x', yaxis: 'y', hoverinfo: 'skip', showlegend: true },
      { x, y: cond_cdf, mode: 'lines', name: 'F_{X|A}(x)', line: { color: '#16a34a', width: 3 }, xaxis: 'x2', yaxis: 'y2' },
      { x, y: pdf, mode: 'lines', name: 'f_X(x)', line: { color: '#2563eb', width: 3 }, xaxis: 'x3', yaxis: 'y3' },
      { x: highlightX, y: highlightPDF, mode: 'lines', name: 'A interval', fill: 'tozeroy', line: { color: 'rgba(239,68,68,0.7)' }, xaxis: 'x3', yaxis: 'y3', hoverinfo: 'skip', showlegend: false },
      { x, y: cond_pdf, mode: 'lines', name: 'f_{X|A}(x)', line: { color: '#16a34a', width: 3 }, xaxis: 'x4', yaxis: 'y4' },
    ];

    const box = plotEl.getBoundingClientRect();
    const measuredHeight = box.height || plotEl.clientHeight || 0;
    const plotHeight = Math.max(520, Math.min(measuredHeight || 0, 720)) || 560;

    const layout = {
      grid: { rows: 2, columns: 2, pattern: 'independent' },
      height: plotHeight,
      margin: { l: 44, r: 10, t: 32, b: 32 },
      legend: { orientation: 'h', y: -0.22, font: { size: 10 } },
      xaxis: { title: '$x$', automargin: true },
      yaxis: { title: '$F_X(x)$', rangemode: 'tozero', automargin: true },
      xaxis2: { title: '$x$', automargin: true },
      yaxis2: { title: '$F_{X|A}(x)$', rangemode: 'tozero', automargin: true },
      xaxis3: { title: '$x$', automargin: true },
      yaxis3: { title: '$f_X(x)$', rangemode: 'tozero', automargin: true },
      xaxis4: { title: '$x$', automargin: true },
      yaxis4: { title: '$f_{X|A}(x)$', rangemode: 'tozero', automargin: true },
      title: { text: `${title}: F_X(x), F_{X|A}(x), f_X(x), f_{X|A}(x)`, x: 0.005, font: { size: 14 } },
      paper_bgcolor: 'white',
      plot_bgcolor: '#f8fafc',
      shapes: [
        { type: 'rect', xref: 'x', yref: 'paper', x0: a_min, x1: a_max, y0: 0, y1: 1, fillcolor: 'rgba(239,68,68,0.08)', line: { width: 0 } },
        { type: 'rect', xref: 'x3', yref: 'paper', x0: a_min, x1: a_max, y0: 0, y1: 1, fillcolor: 'rgba(239,68,68,0.08)', line:{ width: 0 } },
      ],
    };

    Plotly.react(plotEl, traces, layout, { responsive: true, displaylogo: false })
      .then(() => {
        const latexBlocks = [];
        if (latexTitleEl) {
          latexTitleEl.innerHTML = `\\(${title_latex || title}\\): \\(F_X(x), F_{X\mid A}(x), f_X(x), f_{X\mid A}(x)\\)`;
          latexBlocks.push(latexTitleEl);
        }

        if (latexLabelsEl) {
          latexLabelsEl.innerHTML = [
            '\\(F_X(x)\\)',
            '\\(F_{X\\mid A}(x)\\)',
            '\\(f_X(x)\\)',
            '\\(f_{X\\mid A}(x)\\)'
          ].map(expr => `<span class="subplot-label">${expr}</span>`).join('');
          latexBlocks.push(latexLabelsEl);
        }

        if (latexBlocks.length) {
          typesetLatex(latexBlocks);
        }
      });
    }

  function attachListeners() {
    document.querySelectorAll('#controls input[type=range]').forEach(inp => {
      inp.addEventListener('input', recompute);
    });
  }

  document.getElementById('distribution').addEventListener('change', (e) => {
    renderControls(e.target.value);
    recompute();
  });

  renderControls(document.getElementById('distribution').value);
  recompute();
</script>
{% endblock %}