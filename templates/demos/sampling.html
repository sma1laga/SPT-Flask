{% extends "base.html" %}
{% block content %}
<h1>Sampling (Ch. 11)</h1>
<p>
  This demo shows signals in the frequency and time domains before and after sampling with the sampling frequency \(\omega_a\), as described in Chapter&nbsp;11.
  As an example, the input signal \(x(t)\) is
  \[
    x(t) = \frac{\omega_g}{2\pi}\,\mathrm{si}^2\!\left(\tfrac{1}{2}\,\omega_g\,t\right),
  \]
  with spectrum
  \[
    X(j\omega) = \Lambda\!\left(\frac{\omega}{\omega_g}\right)
    = \frac{1}{\omega_g}\,\mathrm{rect}\!\left(\frac{\omega}{\omega_g}\right) * \mathrm{rect}\!\left(\frac{\omega}{\omega_g}\right).
  \]
  The input is sampled to obtain \(x_a(t)\) (slides&nbsp;11-13 to&nbsp;11-14) and reconstructed ideally to obtain \(y(t)\) (slides&nbsp;11-16 to&nbsp;11-18\)).
  You can view \(x_a(t)\) and \(y(t)\) and their spectra \(X_a(j\omega)\) and \(Y(j\omega)\) in time and frequency domains, and optionally display the individual \(\mathrm{si}\)-functions that sum to \(y(t)\).
  Adjust the sampling frequency \(\omega_a\) and the cutoff \(\omega_g\).
</p>

<style>
  .toolbar {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 14px 18px;
    align-items: start;
    margin: 12px 0 10px;
  }
  .group { display: grid; grid-template-columns: 1fr; gap: 8px; }
  .checks { display: grid; grid-template-columns: repeat(2, minmax(180px, 1fr)); gap: 6px 14px; }
  @media (max-width: 900px) { .checks { grid-template-columns: 1fr; } }
  label { font-weight: 600; display: inline-block; margin-bottom: 4px; }
  input[type=number] {
    width: 100%; padding: 7px 8px; border: 1px solid #bbb; border-radius: 8px; background: var(--control-bg, #fff);
  }
  .plots { display: grid; grid-template-columns: 1fr; gap: 14px; }
  #plot { width: 100%; height: auto; display: block; }
</style>

<div class="toolbar">
  <div class="group">
    <div>
      <label for="wg_over_pi">\(\omega_g / \pi\)</label>
      <input id="wg_over_pi" type="number" step="{{ defaults.step }}"
             min="{{ defaults.min_wg }}" max="{{ defaults.max_wg }}"
             value="{{ defaults.w_g_over_pi }}">
    </div>
    <div class="checks">
      <label><input id="show_xt" type="checkbox" {% if defaults.show_xt %}checked{% endif %}> show x(t)</label>
      <label><input id="show_xa" type="checkbox" {% if defaults.show_xa %}checked{% endif %}> show x<sub>a</sub>(t)</label>
      <label><input id="show_yt" type="checkbox" {% if defaults.show_yt %}checked{% endif %}> show y(t)</label>
      <label><input id="show_partials" type="checkbox" {% if defaults.show_partials %}checked{% endif %}> show partial sums of y</label>
    </div>
  </div>

  <div class="group">
    <div>
      <label for="wa_over_pi">\(\omega_a / \pi\)</label>
      <input id="wa_over_pi" type="number" step="{{ defaults.step }}"
             min="{{ defaults.min_wa }}" max="{{ defaults.max_wa }}"
             value="{{ defaults.w_a_over_pi }}">
    </div>
    <div class="checks">
      <label><input id="show_X"  type="checkbox" {% if defaults.show_X %}checked{% endif %}> show \(X(j\omega)\)</label>
      <label><input id="show_Xa" type="checkbox" {% if defaults.show_Xa %}checked{% endif %}> show \(X_a(j\omega)\)</label>
      <label><input id="show_Y"  type="checkbox" {% if defaults.show_Y %}checked{% endif %}> show \(Y(j\omega)\)</label>
    </div>
  </div>
</div>

<div class="plots">
  <img id="plot" alt="Sampling: time and frequency-domain plots">
</div>

<script>
  const $ = (id) => document.getElementById(id);

  let inFlight = null;
  let debounceTimer = null;
  let SEQ = 0;

  function payload() {
    return {
      w_g_over_pi: parseFloat($("wg_over_pi").value),
      w_a_over_pi: parseFloat($("wa_over_pi").value),
      show_xt: $("show_xt").checked,
      show_xa: $("show_xa").checked,
      show_yt: $("show_yt").checked,
      show_partials: $("show_partials").checked,
      show_X: $("show_X").checked,
      show_Xa: $("show_Xa").checked,
      show_Y: $("show_Y").checked,
      seq: ++SEQ
    };
  }

  async function recompute() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(async () => {
      if (inFlight) inFlight.abort();
      inFlight = new AbortController();

      const body = payload();

      try {
        const resp = await fetch("./compute", {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify(body),
          signal: inFlight.signal
        });
        if (!resp.ok) return;
        const data = await resp.json();
        if (data.seq !== undefined && data.seq < SEQ) return;
        if (data.image) $("plot").src = data.image;
      } catch(e) {
    
      } finally {
        inFlight = null;
      }
    }, 80);
  }

  ["wg_over_pi","wa_over_pi","show_xt","show_xa","show_yt","show_partials","show_X","show_Xa","show_Y"].forEach(id => {
    $(id).addEventListener("input",  recompute);
    $(id).addEventListener("change", recompute);
  });

  window.addEventListener("load", recompute);
</script>
{% endblock %}
