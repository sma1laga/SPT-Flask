{% extends "base.html" %}
{% block content %}
  <!-- Page Header -->
  <div class="page-header" style="margin-bottom: 30px; text-align: center;">
    <h1 style="font-size: 2.5em; margin-bottom: 10px;">Convolution Training</h1>
    <p style="font-size: 1.1em; color: var(--subtext-color); max-width: 600px; margin: 0 auto;">
      Practice computing convolutions with customizable difficulty. Generate problems, inspect the plot, and select the correct answer.</p>
  </div>

  <!-- Controls -->
  <div class="controls" style="max-width: 700px; margin: 0 auto 30px; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 20px; text-align: center;">
    <div class="radio-group">
      <label class="radio-label"><input type="radio" name="difficulty" value="EASY" checked> Easy</label>
      <label class="radio-label"><input type="radio" name="difficulty" value="MEDIUM"> Medium</label>
      <label class="radio-label"><input type="radio" name="difficulty" value="HARD"> Hard</label>
    </div>
    <button id="generateBtn" class="action-btn">Generate Problem</button>
  </div>

  <p style="text-align: center; color: var(--subtext-color); margin-top: -10px; margin-bottom: 30px;">
    Tip: You can select \(y_1(t)\)–\(y_4(t)\) with the <strong>1</strong>–<strong>4</strong> keys and load the next plot with the <strong>spacebar</strong>.
  </p>

<!-- Plot Container -->
<div class="plot-container" style="text-align: center; margin-bottom: 20px;">
  <div id="plotWrap" class="plot-wrap" style="position:relative; display:inline-block;">
    <img id="conv_plot_image" src="" alt="Training Convolution Plot"
         style="display:none; max-width:100%; border:1px solid #ccd0d5; border-radius:4px;">
    <!-- Overlay-Hitboxen for y1..y4 -->
    <div id="plotOverlay" class="plot-overlay" style="display:none;">
      <div class="plot-hit" data-index="0" title="Select y₁(t)"></div>
      <div class="plot-hit" data-index="1" title="Select y₂(t)"></div>
      <div class="plot-hit" data-index="2" title="Select y₃(t)"></div>
      <div class="plot-hit" data-index="3" title="Select y₄(t)"></div>
    </div>
  </div>
</div>


  <!-- Answer Options -->
  <div class="options" style="max-width: 700px; margin: 0 auto 20px; display: flex; flex-wrap: wrap; justify-content: center; gap: 15px;">
    <button class="option-btn action-btn" data-index="0">\(y_1(t)\)</button>
    <button class="option-btn action-btn" data-index="1">\(y_2(t)\)</button>
    <button class="option-btn action-btn" data-index="2">\(y_3(t)\)</button>
    <button class="option-btn action-btn" data-index="3">\(y_4(t)\)</button>
    <button id="nextBtn" class="action-btn" style="display:none;">Next Problem</button>
  </div>

  <!-- Feedback -->
  <div id="feedback" class="feedback" style="text-align: center; font-size: 1.1em; color: var(--text-color); min-height: 1.2em;"></div>

<!-- Streak Panel (client-side only) -->
<div id="streakPanel" class="streak-panel" style="max-width:700px;margin:0 auto 8px;display:flex;justify-content:center;gap:12px;align-items:center;">
  <div>Streak: <strong id="streakCur">0</strong></div>
  <div style="opacity:.8;">Best: <strong id="streakBest">0</strong></div>
  <button id="streakReset" class="action-btn" style="padding:6px 10px;background:#555;">Reset</button>
</div>

  <!-- Exam Link -->
  <p style="text-align: center; margin-top: 30px;">
    Want a 10-question exam? <a href="{{ url_for('exam_convolution.start_exam') }}" class="link-btn">Take the Convolution Exam</a>
  </p>

  <!-- Scripts -->
<script>
  // --- State ---
  let correctIndex = null;
  let selectionLocked = false;

  // Prefetch pipeline state
  let cachedProblem = null;     // { plot_data, correctIndex,...}
  let cachedDiff = null;        // difficulty string this cache was created for
  let prefetchCtrl = null;      // abbortController for in-flight prefetch
  let prefetchInFlight = false; // flag to avoid duplicate prefetches
  let answeredThisRound = false;// to trigger prefetch only once per problem

  // Tracks the acctual difficulty of the problem 
  let currentProblemDifficulty = null;

  // Boot-prefetch for first problem (always medium, because its faster)
  let bootCachedProblem = null;
  let bootCtrl = null;
  let bootInFlight = false;

  // --- Hooks ---
  document.getElementById('generateBtn').addEventListener('click', () => {
    // If the preloaded medium-problem exists -< instant plot 
    if (bootCachedProblem) {
      if (bootCtrl) { try { bootCtrl.abort(); } catch(_){}; bootCtrl = null; }
      destroyPrefetch(); // sicherheitshalber
      renderProblemFromData(bootCachedProblem, bootCachedProblem._difficulty); // -> MEDIUM
      bootCachedProblem = null; // Boot-Cache used
      return;
    }
    // 2. no boot cache (user clicks fast) - normal generation 
    destroyPrefetch();
    generateProblem();
  });


  // Plot directly choosable (y1...y4)
  document.querySelectorAll('.plot-hit').forEach(hit => {
    hit.addEventListener('click', () => checkAnswer(parseInt(hit.dataset.index)));
  });
  document.querySelectorAll('.option-btn').forEach(btn => {
    btn.addEventListener('click', () => checkAnswer(parseInt(btn.dataset.index)));
  });

  // Re-Layout of hitboxes
  document.getElementById('conv_plot_image').addEventListener('load', layoutOverlayBoxes);
  window.addEventListener('resize', () => {
    const img = document.getElementById('conv_plot_image');
    if (img.style.display !== 'none') layoutOverlayBoxes();
  });

  document.getElementById('nextBtn').addEventListener('click', onNextProblemClick);

  // Keyboard controls
  let lastSpaceActivation = 0;
  document.addEventListener('keydown', (event) => {
    const tag = (event.target && event.target.tagName) ? event.target.tagName.toUpperCase() : '';
    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

    if (event.key >= '1' && event.key <= '4') {
      event.preventDefault();
      const idx = parseInt(event.key, 10) - 1;
      checkAnswer(idx);
      return;
    }

    if (event.key === ' ' || event.key === 'Spacebar') {
      event.preventDefault();
      const now = Date.now();
      // safety feature for double space in 1 sec
      if (now - lastSpaceActivation < 1000) return;
      lastSpaceActivation = now;

      const nextBtn = document.getElementById('nextBtn');
      if (nextBtn && nextBtn.style.display !== 'none') {
        onNextProblemClick();
      }
    }
  });

  // Destroy cache when difficulty changes (user did something else)
  document.querySelectorAll('input[name="difficulty"]').forEach(radio => {
    radio.addEventListener('change', () => {
      refreshStreakUI();
      destroyPrefetch();
      hidePlot();
      document.getElementById('nextBtn').style.display = 'none';
      showFeedback('Difficulty changed. Generate a problem.');
    });
  });

  // --- Helpers ---
  function getDifficulty() {
    return document.querySelector('input[name="difficulty"]:checked').value;
  }

  function req(url, payload, signal) {
    return fetch(url, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(payload),
      signal
    }).then(r => r.json());
  }

  function renderProblemFromData(data, difficultyTag = null) {
    if (data.error) {
      showFeedback('Error: ' + data.error);
      return;
    }

    currentProblemDifficulty = difficultyTag || getDifficulty();

    const img = document.getElementById('conv_plot_image');
    img.src = 'data:image/png;base64,' + data.plot_data;
    img.style.display = 'block';
    correctIndex = data.correctIndex;
    selectionLocked = false;

    const optBtns = document.querySelectorAll('.option-btn');
    optBtns.forEach(b => {
      b.classList.remove('correct', 'incorrect');
      b.disabled = false;
    });
    document.getElementById('nextBtn').style.display = 'inline-block';
    showFeedback('Problem generated. Select the correct option.');
    resetOverlayUI();
    answeredThisRound = false;
  }


  function hidePlot() {
    const img = document.getElementById('conv_plot_image');
    img.style.display = 'none';
    img.removeAttribute('src');
    const overlay = document.getElementById('plotOverlay');
    overlay.style.display = 'none';
  }

  const AXES_BOUNDS = [
    { x0: 0.125, y0: 0.39875, width: 0.3369565217, height: 0.1925 },
    { x0: 0.5630434783, y0: 0.39875, width: 0.3369565217, height: 0.1925 },
    { x0: 0.125, y0: 0.11, width: 0.3369565217, height: 0.1925 },
    { x0: 0.5630434783, y0: 0.11, width: 0.3369565217, height: 0.1925 }
  ];

  function layoutOverlayBoxes() {
    const img = document.getElementById('conv_plot_image');
    const overlay = document.getElementById('plotOverlay');
    if (!img || img.style.display === 'none') return;


    const w = img.clientWidth;
    const h = img.clientHeight;
    if (!w || !h) return;

    overlay.style.display = 'block';


    const padX = 0.01;  // relative to figure width
    const padY = 0.02;  // relative to figure height

    const hits = document.querySelectorAll('.plot-hit');
    hits.forEach((hit, i) => {
      const bounds = AXES_BOUNDS[i];
      if (!bounds) return;

      const leftNorm = Math.max(0, bounds.x0 - padX);
      const rightNorm = Math.min(1, bounds.x0 + bounds.width + padX);
      const topNorm = Math.max(0, 1 - (bounds.y0 + bounds.height) - padY);
      const bottomNorm = Math.min(1, 1 - bounds.y0 + padY);

      const width = Math.max(0, rightNorm - leftNorm) * w;
      const height = Math.max(0, bottomNorm - topNorm) * h;
      const left = leftNorm * w;
      const top = topNorm * h;

      hit.style.left = left + 'px';
      hit.style.top = top + 'px';
      hit.style.width = width + 'px';
      hit.style.height = height + 'px';
    });
  }

  function resetOverlayUI() {
    const overlay = document.getElementById('plotOverlay');
    overlay.style.display = 'block';
    document.querySelectorAll('.plot-hit').forEach(h => {
      h.classList.remove('correct','incorrect');
      h.style.pointerEvents = 'auto';
    });
    layoutOverlayBoxes();
  }


  // Main flows 
  function generateProblem() {
    const diff = getDifficulty();
    if (!diff) return showFeedback('Please select a difficulty first!');
    // Render fresh problem from server
    req("{{ url_for('training_convolution.generate_problem') }}", { difficulty: diff })
  .then(data => {
    data._difficulty = diff;               // tag
    renderProblemFromData(data, diff);     // set active problem diff. 
  })      
  .catch(() => showFeedback('Error generating problem.'));
  }

  function onNextProblemClick() {
    const diff = getDifficulty();

    // If we have a warm problem for this difficulty -> instant render
    if (cachedProblem && cachedDiff === diff) {
      const warm = cachedProblem;
      cachedProblem = null; // consume cache
      renderProblemFromData(warm, warm._difficulty); // zeigt die korrekte, getaggte Difficulty
      // Immediately start prefetch for the next problem
      prefetchNextProblem();
    } else {
      // No cache available -> normal generation
      generateProblem();
    }
  }

  function checkAnswer(selected) {
    if (correctIndex === null) return showFeedback('Please generate a problem first!');
    if (selectionLocked) return;
    selectionLocked = true;
    req("{{ url_for('training_convolution.check_answer') }}", {
      selectedIndex: selected, correctIndex: correctIndex
    })
    .then(data => {
      const buttons = document.querySelectorAll('.option-btn');
      buttons.forEach(b => b.disabled = true);
      buttons[correctIndex].classList.add('correct');
      // Plot-Overlay visually marked
      const hits = document.querySelectorAll('.plot-hit');
      hits.forEach(h => h.style.pointerEvents = 'none');
      // right option green, false red
      hits[correctIndex].classList.add('correct');
      if (selected !== correctIndex) hits[selected].classList.add('incorrect');
      if (selected !== correctIndex) buttons[selected].classList.add('incorrect');
      showFeedback(data.feedback || '');
      const isCorrect = (selected === correctIndex);
      bumpStreak(isCorrect);

      // Kick off background prefetch ONCE per round
      if (!answeredThisRound) {
        answeredThisRound = true;
        prefetchNextProblem();
      }
    })
    .catch(() => {
      selectionLocked = false;
      showFeedback('Error checking answer.');
    });
  }

  // --- Prefetch pipeline ---
  function prefetchNextProblem() {
    const diff = getDifficulty();

    // If something is in-flight or we already have a warm one for this diff, skip
    if (prefetchInFlight) return;
    if (cachedProblem && cachedDiff === diff) return;

    // Abort any old prefetch
    destroyPrefetch(false);

    prefetchCtrl = new AbortController();
    prefetchInFlight = true;
    cachedProblem = null;
    cachedDiff = diff;

    req("{{ url_for('training_convolution.generate_problem') }}", { difficulty: diff }, prefetchCtrl.signal)
      .then(data => {
        if (getDifficulty() === diff) {
          data._difficulty = diff; // merken, worauf dieses Prefetch passt
          cachedProblem = data;
          cachedDiff = diff;
        }
      })
      .catch(() => { /* aborted or failed -> ignore */ })
      .finally(() => { prefetchInFlight = false; });
  }
  function prefetchBootMedium() {
    if (bootInFlight || bootCachedProblem) return; // only once
    bootCtrl = new AbortController();
    bootInFlight = true;
    req("{{ url_for('training_convolution.generate_problem') }}", { difficulty: "MEDIUM" }, bootCtrl.signal)
      .then(data => {
        data._difficulty = "MEDIUM";
        bootCachedProblem = data;
      })
      .catch(() => { /* ignore */ })
      .finally(() => { bootInFlight = false; });
  }

  function destroyPrefetch(abort = true) {
    if (abort && prefetchCtrl) {
      try { prefetchCtrl.abort(); } catch(_) {}
    }
    prefetchCtrl = null;
    prefetchInFlight = false;
    cachedProblem = null;
    cachedDiff = null;
  }

  function showFeedback(msg) {
    document.getElementById('feedback').innerText = msg;
  }
// ===== Streak (client-side, per difficulty) =====
function streakKey(diff){ return `conv:streak:${diff}`; }
function bestKey(diff){ return `conv:best:${diff}`; }
function readInt(k){ const v = localStorage.getItem(k); return v ? parseInt(v,10) : 0; }
function writeInt(k,v){ localStorage.setItem(k, String(v)); }

function getStreak(diff){ return readInt(streakKey(diff)); }
function setStreak(diff,v){ writeInt(streakKey(diff), v); }
function getBest(diff){ return readInt(bestKey(diff)); }
function setBest(diff,v){ writeInt(bestKey(diff), v); }

function refreshStreakUI(){
  const diff = getDifficulty();
  document.getElementById('streakCur').textContent = getStreak(diff);
  document.getElementById('streakBest').textContent = getBest(diff);
}

function bumpStreak(isCorrect){
  const diff = currentProblemDifficulty || getDifficulty();
  if (isCorrect){
    const cur = getStreak(diff) + 1;
    setStreak(diff, cur);
    if (cur > getBest(diff)) setBest(diff, cur);
    flashStreak();
  } else {
    setStreak(diff, 0);
  }
  refreshStreakUI();
}


function flashStreak(){
  const el = document.getElementById('streakPanel');
  el.style.transition = 'transform 0.2s ease';
  el.style.transform = 'scale(1.05)';
  setTimeout(() => { el.style.transform = 'scale(1)'; }, 200);
}

// Reset button (resets current difficulty only)
document.getElementById('streakReset').addEventListener('click', () => {
  const diff = getDifficulty();
  setStreak(diff, 0);
  refreshStreakUI();
});
prefetchBootMedium();
refreshStreakUI();
</script>


  <!-- Styles -->
  <style>
    .radio-group {
      display: flex;
      gap: 15px;
    }
    .radio-label {
      font-size: 1em;
    }
    .radio-label input {
      margin-right: 6px;
    }
    .action-btn {
      padding: 10px 20px;
      background-color: var(--primary-color);
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.2s ease;
    }
    .action-btn:hover {
      background-color: var(--primary-color-darker);
    }
    #nextBtn {
      background-color: var(--lms-green-darker);
    }
    #nextBtn:hover {
      background-color: var(--lms-green-dark);
    }
    .feedback {
      min-height: 1.4em;
      margin-top: 10px;
    }
    .link-btn {
      color: var(--primary-color);
      text-decoration: none;
      font-weight: bold;
    }
    .link-btn:hover {
      text-decoration: underline;
    }
    .option-btn.correct {
      background-color: var(--lms-green-darker);
    }
    .option-btn.incorrect {
      background-color: var(--lms-red);
    }
    /* Overlay exakt über dem Bild */
    .plot-wrap {
      position: relative;
      display: inline-block;
    }
    .plot-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    /* Klickbare Bereiche (Hitboxen) */
    .plot-hit {
      position: absolute;
      border: 2px solid transparent;
      border-radius: 8px;
      box-shadow: 0 0 0 0 rgba(0,0,0,0);
      transition: box-shadow 0.12s ease, border-color 0.12s ease;
      pointer-events: auto; /* wichtig für Klicks */
      cursor: pointer;
      box-sizing: border-box;
    }

    /* Subtiler Hover-Ring */
    .plot-hit:hover {
      box-shadow: 0 0 0 2px rgba(0,122,204,0.28);
    }

    /* Ergebniszustände */
    .plot-hit.correct {
      border-color: #28a745;
      box-shadow: 0 0 0 2px rgba(40,167,69,0.5);
    }
    .plot-hit.incorrect {
      border-color: #c0392b;
      box-shadow: 0 0 0 2px rgba(192,57,43,0.5);
    }

  </style>
{% endblock %}