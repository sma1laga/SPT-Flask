{% extends "base.html" %}
{% block content %}
<div class="page-header" style="margin-bottom:30px;text-align:center;">
  <h1 style="font-size:2.5em;margin-bottom:10px;">Processing Chain Training</h1>
  <p style="font-size:1.1em;color:var(--subtext-color);max-width:620px;margin:0 auto;">
    Practice analysing processing chains in the frequency domain.  Easy problems use
    three serial blocks chosen from multiplication, Hilbert and filtering, Medium
    problems introduce branching with sampling, derivatives and adders, and Hard
    problems add modulation loops that mix sampling with real/imaginary splitting
    before recombining through additional filters.  For every labelled connection
    you must identify the correct output among three plotted options.
  </p>
</div>

<!-- Controls -->
<div class="controls" style="max-width:700px;margin:0 auto 30px;display:flex;flex-wrap:wrap;justify-content:center;align-items:center;gap:20px;text-align:center;">
  <div class="radio-group">
    <label class="radio-label"><input type="radio" name="difficulty" value="EASY" checked> Easy</label>
    <label class="radio-label"><input type="radio" name="difficulty" value="MEDIUM"> Medium</label>
    <label class="radio-label"><input type="radio" name="difficulty" value="HARD"> Hard</label>
  </div>
  <button id="generateBtn" class="action-btn">Generate Problem</button>
</div>

<!-- Diagram -->
<div style="text-align:center;margin-bottom:20px;">
  <img id="diagram_image" alt="Processing chain diagram" style="max-width:100%;display:none;border:1px solid var(--border-color,#ccd0d5);border-radius:4px;" />
</div>
<div id="diagramSummary" style="display:none;max-width:600px;margin:0 auto 25px;padding:12px 16px;border:1px solid var(--border-color,#ccd0d5);border-radius:6px;background-color:var(--panel-bg,#f8f9fb);">  <h3 style="margin:0 0 8px 0;font-size:1.1em;color:var(--text-color);text-align:center;">Connection summary</h3>
  <ul id="diagramSummaryList" style="list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:6px;font-size:0.95em;color:var(--text-color);"></ul>
</div>
<!-- Input spectrum -->
<div id="inputSection" style="display:none;text-align:center;margin-bottom:25px;">
  <p id="input_expression" style="margin-bottom:10px;font-size:1.05em;color:var(--text-color);"></p>
  <img id="input_plot" alt="Input spectrum" style="max-width:100%;border:1px solid var(--border-color,#ccd0d5);border-radius:4px;display:none;" />
</div>

<!-- Letters container -->
<div id="lettersContainer" style="max-width:900px;margin:0 auto;display:flex;flex-direction:column;gap:25px;"></div>

<!-- Next Problem button -->
<div style="text-align:center;margin-top:20px;">
  <button id="nextBtn" class="action-btn" style="display:none;">Next Problem</button>
</div>

<!-- Feedback -->
<div id="feedback" style="text-align:center;font-size:1.1em;color:var(--text-color);min-height:1.2em;margin-top:10px;"></div>

<!-- Score and streak panels -->
<div id="scorePanel" style="max-width:420px;margin:24px auto 10px;padding:14px 18px;border:1px solid var(--border-color,#ccd0d5);border-radius:8px;background-color:var(--panel-bg,#f8f9fb);text-align:center;">
  <div style="font-size:1.05em;color:var(--text-color);">Correct answers: <strong id="scoreCorrect">0</strong><span style="opacity:.8;"> / <span id="scoreTotal">0</span></span></div>
  <div id="accuracyRow" style="margin-top:6px;font-size:0.95em;color:var(--subtext-color);">Accuracy: <strong id="scoreAccuracy">0%</strong></div>
</div>

<div id="streakPanel" style="max-width:420px;margin:0 auto 0;padding:10px 16px;border:1px solid var(--border-color,#ccd0d5);border-radius:8px;background-color:var(--panel-bg,#f8f9fb);display:flex;justify-content:center;gap:12px;align-items:center;">
  <div>Streak: <strong id="streakCur">0</strong></div>
  <div style="opacity:.8;">Best: <strong id="streakBest">0</strong></div>
  <button id="streakReset" class="action-btn" style="padding:6px 12px;background:#555;">Reset</button>
</div>


<script>
// Store current problem data
let currentProblem = null;
let answeredLetters = 0;
let currentProblemDifficulty = null;

const memoryStore = {};
let storageAvailable = true;
try {
  const testKey = "procchain:test";
  window.localStorage.setItem(testKey, "1");
  window.localStorage.removeItem(testKey);
} catch (err) {
  storageAvailable = false;
}

function safeGetItem(key) {
  if (storageAvailable) {
    const value = window.localStorage.getItem(key);
    if (value !== null) {
      return value;
    }
  }
  return Object.prototype.hasOwnProperty.call(memoryStore, key) ? memoryStore[key] : null;
}

function safeSetItem(key, value) {
  if (storageAvailable) {
    try {
      window.localStorage.setItem(key, value);
      memoryStore[key] = value;
      return;
    } catch (err) {
      storageAvailable = false;
    }
  }
  memoryStore[key] = value;
}

function getDifficulty() {
  return document.querySelector('input[name="difficulty"]:checked').value;
}

// Helper to send POST requests
function postJson(url, payload) {
  return fetch(url, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(payload)
  }).then(r => r.json());
}

// Render the problem to the DOM
function renderProblem() {
  if (!currentProblem || currentProblem.error) {
    const msg = currentProblem ? currentProblem.error : 'No problem data.';
    document.getElementById('feedback').textContent = msg;
    return;
  }
  // reset answered count
  answeredLetters = 0;
  document.getElementById('nextBtn').style.display = 'none';
  document.getElementById('feedback').textContent = 'Problem generated. Select the correct outputs.';
  currentProblemDifficulty = currentProblemDifficulty || getDifficulty();
  const selected = getDifficulty();
  refreshStatsUI(selected);
  refreshStreakUI(selected);
  // show input details
  const inputSection = document.getElementById('inputSection');
  const inputExpr = document.getElementById('input_expression');
  const inputPlot = document.getElementById('input_plot');
  const summaryBox = document.getElementById('diagramSummary');
  const summaryList = document.getElementById('diagramSummaryList');
  const mathElements = [];
  if (currentProblem.inputExpressionLatex) {
    inputExpr.innerHTML = 'Input spectrum: \\(' + currentProblem.inputExpressionLatex + '\\)';
    mathElements.push(inputExpr);

  } else if (currentProblem.inputExpression) {
    inputExpr.textContent = 'Input spectrum: ' + currentProblem.inputExpression;
  } else {
    inputExpr.textContent = '';
  }
  if (currentProblem.inputPlot) {
    inputPlot.src = 'data:image/png;base64,' + currentProblem.inputPlot;
    inputPlot.style.display = 'block';
  } else {
    inputPlot.removeAttribute('src');
    inputPlot.style.display = 'none';
  }
  inputSection.style.display = 'block';
  // show diagram
  const diag = document.getElementById('diagram_image');
  diag.src = 'data:image/png;base64,' + currentProblem.diagram;
  diag.style.display = 'block';
  summaryList.innerHTML = '';
  const ops = Array.isArray(currentProblem.diagramOperations) ? currentProblem.diagramOperations : [];
  if (ops.length) {
    ops.forEach(op => {
      const li = document.createElement('li');
      if (op.summaryLatex) {
        li.innerHTML = '\\(' + op.summaryLatex + '\\)';
        mathElements.push(li);
      } else {
        const strong = document.createElement('strong');
        strong.textContent = op.letter + ':';
        li.appendChild(strong);
        const signalSpan = document.createElement('span');
        signalSpan.textContent = ' ' + (op.signal || '');
        li.appendChild(signalSpan);
        li.appendChild(document.createTextNode(' after '));
        const nameEm = document.createElement('em');
        nameEm.textContent = op.name || '';
        li.appendChild(nameEm);
        if (op.parameter) {
          li.appendChild(document.createTextNode(' (' + op.parameter + ')'));
        }
      }
      summaryList.appendChild(li);
    });
    summaryBox.style.display = 'block';
  } else {
    summaryBox.style.display = 'none';
  }
  // clear container
  const container = document.getElementById('lettersContainer');
  container.innerHTML = '';
  // create sections for each letter
  currentProblem.letters.forEach((letterObj, idx) => {
    const section = document.createElement('div');
    section.className = 'letter-section';
    // heading
    const h = document.createElement('h3');
    const signalName = letterObj.signalLabel || letterObj.letter;
    if (letterObj.signalLabelLatex) {
      h.innerHTML = 'Signal \\(' + letterObj.signalLabelLatex + '\\)';
      mathElements.push(h);
    } else {
      h.textContent = 'Signal ' + signalName;
    }
    section.appendChild(h);
    // image options
    const imgRow = document.createElement('div');
    imgRow.style.display = 'flex';
    imgRow.style.flexWrap = 'wrap';
    imgRow.style.gap = '10px';
    letterObj.images.forEach((imgData, optIdx) => {
      const wrapper = document.createElement('div');
      wrapper.style.cursor = 'pointer';
      wrapper.style.border = '2px solid transparent';
      wrapper.style.borderRadius = '4px';
      // embed letter and option indices for handler
      wrapper.dataset.letterIndex = idx;
      wrapper.dataset.optionIndex = optIdx;
      const img = document.createElement('img');
      img.src = 'data:image/png;base64,' + imgData;
      img.style.maxWidth = '260px';
      img.style.borderRadius = '4px';
      wrapper.appendChild(img);
      wrapper.addEventListener('click', onOptionClick);
      imgRow.appendChild(wrapper);
    });
    section.appendChild(imgRow);
    container.appendChild(section);
  });

  if (mathElements.length && window.MathJax) {
    if (MathJax.typesetPromise) {
      MathJax.typesetPromise(mathElements).catch(() => {});
    } else if (MathJax.typeset) {
      MathJax.typeset(mathElements);
    }
  }
}

function onOptionClick(evt) {
  const wrapper = evt.currentTarget;
  const letterIndex = parseInt(wrapper.dataset.letterIndex);
  const optionIndex = parseInt(wrapper.dataset.optionIndex);
  const letterObj = currentProblem.letters[letterIndex];
  // disable clicks for this letter if already answered
  const section = wrapper.parentElement;
  if (section.dataset.answered === 'true') return;
  // call server to check answer
  // Post to the check_answer endpoint using url_for.  The blueprint
  // name ``training_processing_chain`` is registered in main.py, so
  // url_for resolves correctly.
  postJson("{{ url_for('training_processing_chain.check_answer') }}", {
    selectedIndex: optionIndex,
    correctIndex: letterObj.correctIndex
  }).then(res => {
    const isCorrect = optionIndex === letterObj.correctIndex;
    // mark images
    const siblings = wrapper.parentElement.children;
    for (let i = 0; i < siblings.length; i++) {
      const elem = siblings[i];
      elem.style.pointerEvents = 'none';
      if (i === letterObj.correctIndex) {
        elem.style.border = '2px solid var(--green-color, #28a745)';
      }
      if (i === optionIndex && i !== letterObj.correctIndex) {
        elem.style.border = '2px solid var(--red-color, #dc3545)';
      }
    }
    section.dataset.answered = 'true';
    // update feedback text
    document.getElementById('feedback').textContent = res.feedback;
    recordAnswer(isCorrect);
    bumpStreak(isCorrect);
    // increase answered count
    answeredLetters += 1;
    if (answeredLetters === currentProblem.letters.length) {
      document.getElementById('nextBtn').style.display = 'inline-block';
    }
  });
}

// Generate button handler
document.getElementById('generateBtn').addEventListener('click', () => {
  // clear any previous problem state
  currentProblem = null;
  document.getElementById('diagram_image').style.display = 'none';
  document.getElementById('diagramSummary').style.display = 'none';
  document.getElementById('diagramSummaryList').innerHTML = '';
  document.getElementById('inputSection').style.display = 'none';
  document.getElementById('lettersContainer').innerHTML = '';
  document.getElementById('feedback').textContent = 'Generating problem…';
  // Use url_for to resolve the generate endpoint.  See comment above.
  const selectedDifficulty = getDifficulty();
  postJson("{{ url_for('training_processing_chain.generate_problem') }}", {
    difficulty: selectedDifficulty
  }).then(data => {
    currentProblemDifficulty = selectedDifficulty;
    currentProblem = data;
    renderProblem();
  }).catch(() => {
    document.getElementById('feedback').textContent = 'Error generating problem.';
  });
});

// Next Problem button handler
document.getElementById('nextBtn').addEventListener('click', () => {
  document.getElementById('nextBtn').style.display = 'none';
  document.getElementById('feedback').textContent = '';
  document.getElementById('diagram_image').style.display = 'none';
  document.getElementById('diagramSummary').style.display = 'none';
  document.getElementById('diagramSummaryList').innerHTML = '';
  document.getElementById('inputSection').style.display = 'none';
  document.getElementById('lettersContainer').innerHTML = '';
  currentProblem = null;
  currentProblemDifficulty = null;
});

document.querySelectorAll('input[name="difficulty"]').forEach(radio => {
  radio.addEventListener('change', () => {
    currentProblemDifficulty = null;
    const diff = getDifficulty();
    refreshStatsUI(diff);
    refreshStreakUI(diff);
  });
});

function statsKey(diff) { return `procchain:stats:${diff}`; }
function streakKey(diff) { return `procchain:streak:${diff}`; }
function bestKey(diff) { return `procchain:best:${diff}`; }

function sanitiseCount(value) {
  const num = Number(value);
  if (!Number.isFinite(num) || num < 0) return 0;
  return Math.round(num);
}

function readStats(diff) {
  const raw = safeGetItem(statsKey(diff));
  if (!raw) return {correct: 0, total: 0};
  try {
    const parsed = JSON.parse(raw);
    return {
      correct: sanitiseCount(parsed.correct),
      total: sanitiseCount(parsed.total)
    };
  } catch (err) {
    return {correct: 0, total: 0};
  }
}

function writeStats(diff, stats) {
  const payload = JSON.stringify({
    correct: sanitiseCount(stats.correct),
    total: sanitiseCount(stats.total)
  });
  safeSetItem(statsKey(diff), payload);
}

function readInt(key) {
  const raw = safeGetItem(key);
  if (!raw) return 0;
  const parsed = parseInt(raw, 10);
  return Number.isFinite(parsed) && parsed > 0 ? parsed : 0;
}

function writeInt(key, value) {
  const normalised = sanitiseCount(value);
  safeSetItem(key, String(normalised));
}

function refreshStatsUI(diffOverride) {
  const diff = diffOverride || getDifficulty();
  const stats = readStats(diff);
  const correct = sanitiseCount(stats.correct);
  const total = sanitiseCount(stats.total);
  document.getElementById('scoreCorrect').textContent = correct;
  document.getElementById('scoreTotal').textContent = total;
  const accuracy = total > 0 ? (correct / total) * 100 : 0;
  let accuracyText = accuracy.toFixed(1);
  if (Math.abs(accuracy - Math.round(accuracy)) < 0.05) {
    accuracyText = Math.round(accuracy).toString();
  }
  document.getElementById('scoreAccuracy').textContent = `${accuracyText}%`;
}

function recordAnswer(isCorrect) {
  const diff = currentProblemDifficulty || getDifficulty();
  const stats = readStats(diff);
  const totalBefore = sanitiseCount(stats.total);
  const correctBefore = sanitiseCount(stats.correct);
  const totalAfter = totalBefore + 1;
  const correctAfter = isCorrect ? correctBefore + 1 : correctBefore;
  writeStats(diff, { correct: correctAfter, total: totalAfter });
  const selected = getDifficulty();
  refreshStatsUI(selected);
  if (isCorrect && selected === diff) {
    flashScorePanel();
  }
}

function getStreak(diff) { return readInt(streakKey(diff)); }
function setStreak(diff, value) { writeInt(streakKey(diff), value); }
function getBest(diff) { return readInt(bestKey(diff)); }
function setBest(diff, value) { writeInt(bestKey(diff), value); }

function refreshStreakUI(diffOverride) {
  const diff = diffOverride || getDifficulty();
  document.getElementById('streakCur').textContent = getStreak(diff);
  document.getElementById('streakBest').textContent = getBest(diff);
}

function bumpStreak(isCorrect) {
  const diff = currentProblemDifficulty || getDifficulty();
  if (isCorrect) {
    const cur = getStreak(diff) + 1;
    setStreak(diff, cur);
    if (cur > getBest(diff)) {
      setBest(diff, cur);
    }
  } else {
    setStreak(diff, 0);
  }
  const selected = getDifficulty();
  refreshStreakUI(selected);
  if (isCorrect && selected === diff) {
    flashStreak();
  }
}

function flashStreak() {
  const el = document.getElementById('streakPanel');
  if (!el) return;
  el.style.transition = 'transform 0.2s ease';
  el.style.transform = 'scale(1.05)';
  setTimeout(() => {
    el.style.transform = 'scale(1)';
  }, 200);
}

function flashScorePanel() {
  const el = document.getElementById('scorePanel');
  if (!el) return;
  el.style.transition = 'transform 0.2s ease';
  el.style.transform = 'scale(1.05)';
  setTimeout(() => {
    el.style.transform = 'scale(1)';
  }, 200);
}

document.getElementById('streakReset').addEventListener('click', () => {
  const diff = getDifficulty();
  setStreak(diff, 0);
  refreshStreakUI(diff);
});

const initialDiff = getDifficulty();
refreshStatsUI(initialDiff);
refreshStreakUI(initialDiff);
</script>
<style>
  .radio-group { display: flex; gap: 15px; }
  .radio-label { font-size: 1em; }
  .radio-label input { margin-right: 6px; }
  .action-btn {
    padding: 10px 20px;
    background-color: #007acc;
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1em;
    transition: background-color 0.2s ease, transform 0.2s ease;
  }
  .action-btn:hover { background-color: #005fa3; }
  #nextBtn {
    background-color: #3CB371;
  }
  #nextBtn:hover { background-color: #2E8B57; }
  #scorePanel strong {
    color: var(--text-color);
  }
  #streakPanel {
    margin-top: 12px;
  }
  #streakPanel .action-btn {
    font-size: 0.9em;
    background-color: #555;
  }
  #streakPanel .action-btn:hover {
    background-color: #333;
  }
</style>
{% endblock %}