
{% extends "base.html" %}
{% block content %}
  <div class="page-header" style="margin-bottom: 22px; text-align: center;">
    <h1 style="font-size: 2.2em; margin-bottom: 6px;">Fourier Transform Training — Exam Style</h1>
    <p style="font-size: 1.05em; color: var(--subtext-color); max-width: 820px; margin: 0 auto;">
      Choose the correct answer row that matches the given plot(s)
      Black plots are the given data; <span style="color:#2e8b57;font-weight:600;">green</span> plots are the answer proposals.
    </p>
  </div>

  <div class="controls" style="max-width: 900px; margin: 0 auto 16px; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 20px; text-align: center;">
    <div class="radio-group" aria-label="Transform direction">
      <label class="radio-label"><input type="radio" name="direction" value="TIME_TO_FREQ" checked> Time → Frequency</label>
      <label class="radio-label"><input type="radio" name="direction" value="FREQ_TO_TIME"> Frequency → Time</label>
    </div>
    <div class="radio-group" aria-label="Difficulty">
      <label class="radio-label"><input type="radio" name="difficulty" value="EASY" checked> Easy</label>
      <label class="radio-label"><input type="radio" name="difficulty" value="MEDIUM"> Medium</label>
      <label class="radio-label"><input type="radio" name="difficulty" value="HARD"> Hard</label>
    </div>
    <button id="generateBtn" class="action-btn">Generate Problem</button>
  </div>

  <p style="text-align: center; color: var(--subtext-color); margin: -10px 0 18px;">
    Tip: Use <strong>1–4</strong> to pick a row and <strong>space</strong> for the next problem.
  </p>

  <div class="plot-container" style="text-align: center; margin-bottom: 10px;">
    <div id="plotWrap" class="plot-wrap" style="position:relative; display:inline-block;">
      <img id="fourier_plot_image" src="" alt="Fourier Training Plot"
           style="display:none; max-width:100%; border:1px solid #ccd0d5; border-radius:6px;">
      <div id="plotOverlay" class="plot-overlay" style="display:none;">
      </div>
    </div>
  </div>

  <div class="options" style="max-width: 820px; margin: 0 auto 18px; display: flex; flex-wrap: wrap; justify-content: center; gap: 12px;">
    <button class="option-btn action-btn" data-index="0">\(\mathcal{O}_1\)</button>
    <button class="option-btn action-btn" data-index="1">\(\mathcal{O}_2\)</button>
    <button class="option-btn action-btn" data-index="2">\(\mathcal{O}_3\)</button>
    <button class="option-btn action-btn" data-index="3">\(\mathcal{O}_4\)</button>
    <button id="nextBtn" class="action-btn" style="display:none;background:#3CB371;">Next Problem</button>
  </div>

  <div id="feedback" class="feedback" style="text-align: center; font-size: 1.05em; color: var(--text-color); min-height: 1.2em;"></div>

  <div id="streakPanel" class="streak-panel" style="max-width:900px;margin:6px auto 10px;display:flex;justify-content:center;gap:12px;align-items:center;">
    <div>Streak: <strong id="streakCur">0</strong></div>
    <div style="opacity:.8;">Best: <strong id="streakBest">0</strong></div>
    <button id="streakReset" class="action-btn" style="padding:6px 10px;background:#555;">Reset</button>
  </div>

  <div id="explanationCard" class="explanation-card" style="display:none; max-width:900px; margin: 14px auto 0; padding: 16px 20px; border:1px solid #d8dce3; border-radius:8px; background: var(--surface-color, #f8f9fb); color: var(--text-color);">
    <h2 style="margin-top:0; font-size:1.25em;">Solution Insight</h2>
    <p id="latexSignal" style="margin-bottom:10px;"></p>
    <p id="latexTransform" style="margin-bottom:10px;"></p>
    <p id="property" style="margin-bottom:0; font-style: italic;"></p>
  </div>

  <script>
  // --- State ---
  let correctIndex = null;
  let currentHitBoxes = []; // from server, in figure normalized coords
  let latexSignal = ''; let latexTransform = ''; let propMsg = '';
  let currentProblemDifficulty = null, currentProblemDirection = null, currentProblemSignature = null;

  let cachedProblem = null, cachedSignature = null, prefetchCtrl = null, prefetchInFlight = false;
  let prefetchTargetSignature = null;
  let prefetchPromise = null;
  let pendingWarmRequest = null;
  let answeredThisRound = false;


  function getDifficulty(){ const x=document.querySelector('input[name="difficulty"]:checked'); return x?x.value:null; }
  function getDirection(){ const x=document.querySelector('input[name="direction"]:checked'); return x?x.value:null; }
  function signatureFor(d,dir){ return `${d}|${dir}`; }

  function req(url, payload, signal){ return fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload),signal}).then(r=>r.json()); }

  function renderProblemFromData(data, diffTag=null, dirTag=null){
    if (data.error){ showFeedback('Error: '+data.error); return; }
    currentProblemDifficulty = diffTag || getDifficulty();
    currentProblemDirection = dirTag || getDirection();
    currentProblemSignature = signatureFor(currentProblemDifficulty, currentProblemDirection);

    latexSignal = data.latex_time || ''; latexTransform = data.latex_freq || ''; propMsg = data.property_msg || '';

    const img = document.getElementById('fourier_plot_image');
    img.src = 'data:image/png;base64,' + data.plot_data;
    img.style.display = 'block';

    correctIndex = data.correctIndex;
    currentHitBoxes = data.hit_boxes || [];

    const overlay = document.getElementById('plotOverlay');
    overlay.innerHTML = ''; // rebuilt hits
    for (let i=0;i<4;i++){
      const h = document.createElement('div');
      h.className = 'plot-hit';
      h.dataset.index = i;
      h.title = `Select \\(\\mathcal{O}_${i+1}\\)`;
      h.addEventListener('click', () => checkAnswer(i));
      overlay.appendChild(h);
    }

    document.querySelectorAll('.option-btn').forEach(b=>{ b.classList.remove('correct','incorrect'); b.disabled=false; });
    document.getElementById('nextBtn').style.display='inline-block';
    showFeedback('Problem generated. Pick the correct row.');
    hideExplanation();
    resetOverlayUI();
    answeredThisRound = false;
  }

  function hidePlot(){
    const img=document.getElementById('fourier_plot_image');
    img.style.display='none'; img.removeAttribute('src');
    const overlay=document.getElementById('plotOverlay'); overlay.style.display='none'; overlay.innerHTML='';
    correctIndex=null; currentHitBoxes=[];
  }

  function layoutOverlayBoxes(){
    const img=document.getElementById('fourier_plot_image');
    const overlay=document.getElementById('plotOverlay');
    if (!img || img.style.display==='none' || !currentHitBoxes.length){ overlay.style.display='none'; return; }
    const w = img.clientWidth, h = img.clientHeight; if(!w||!h) return;
    overlay.style.display='block';
    const hits = overlay.querySelectorAll('.plot-hit');
    hits.forEach((hit,i)=>{
      const b = currentHitBoxes[i]; if(!b) return;
      const [x0,y0,width,height]=b;
      const left = x0*w, top=(1-(y0+height))*h; // convert from fig-norm to CSS
      hit.style.left = left+'px'; hit.style.top = top+'px';
      hit.style.width = (width*w)+'px'; hit.style.height = (height*h)+'px';
    });
  }

  function resetOverlayUI(){
    const overlay=document.getElementById('plotOverlay');
    overlay.style.display='block';
    overlay.querySelectorAll('.plot-hit').forEach(h=>{ h.classList.remove('correct','incorrect'); h.style.pointerEvents='auto'; });
    layoutOverlayBoxes();
  }

  function hideExplanation(){
    const card=document.getElementById('explanationCard');
    card.style.display='none';
    document.getElementById('latexSignal').innerHTML='';
    document.getElementById('latexTransform').innerHTML='';
    document.getElementById('property').textContent='';
  }
  function showExplanation(){
    const card=document.getElementById('explanationCard');
    document.getElementById('latexSignal').innerHTML = latexSignal?`$${latexSignal}$`:'';
    document.getElementById('latexTransform').innerHTML = latexTransform?`$${latexTransform}$`:'';
    document.getElementById('property').textContent = propMsg||'';
    card.style.display='block';
    if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
  }

  document.getElementById('generateBtn').addEventListener('click', ()=>{
    const diff=getDifficulty(), dir=getDirection();
    if(!diff||!dir) return showFeedback('Please choose a direction and difficulty first.');
    const sig=signatureFor(diff,dir);
    const warmed=consumeCachedProblem(sig);
    if(warmed){ renderProblemFromData(warmed, warmed._difficulty, warmed._direction); return; }
    if(prefetchPromise && prefetchTargetSignature===sig){
      const waitPromise=prefetchPromise; pendingWarmRequest={sig, diff, dir, from:'generate'};
      waitPromise.then(()=>{
        if(!pendingWarmRequest || pendingWarmRequest.sig!==sig) return;
        pendingWarmRequest=null;
        const warmAgain=consumeCachedProblem(sig);
        if(warmAgain){ renderProblemFromData(warmAgain, warmAgain._difficulty, warmAgain._direction); }
        else { destroyPrefetch(false); generateProblem(); }
      }).catch(()=>{
        if(!pendingWarmRequest || pendingWarmRequest.sig!==sig) return;
        pendingWarmRequest=null;
        destroyPrefetch(false); generateProblem();
      });
      showFeedback('Preparing problem…');
      return;
    }
    destroyPrefetch();
    generateProblem();
  });

  document.querySelectorAll('.option-btn').forEach(btn => btn.addEventListener('click', ()=>checkAnswer(parseInt(btn.getAttribute('data-index')))));

  document.getElementById('fourier_plot_image').addEventListener('load', layoutOverlayBoxes);
  window.addEventListener('resize', ()=>{ const img=document.getElementById('fourier_plot_image'); if (img.style.display!=='none') layoutOverlayBoxes(); });

  document.getElementById('nextBtn').addEventListener('click', onNextProblemClick);

  let lastSpace=0;
  document.addEventListener('keydown', (ev)=>{
    const tag=(ev.target&&ev.target.tagName)?ev.target.tagName.toUpperCase():'';
    if (tag==='INPUT'||tag==='TEXTAREA'||tag==='SELECT') return;
    if (ev.key>='1'&&ev.key<='4'){ ev.preventDefault(); checkAnswer(parseInt(ev.key,10)-1); return; }
    if (ev.key===' '||ev.key==='Spacebar'){
      ev.preventDefault(); const now=Date.now(); if(now-lastSpace<850) return; lastSpace=now;
      const next=document.getElementById('nextBtn'); if(next && next.style.display!=='none') onNextProblemClick();
    }
  });

  document.querySelectorAll('input[name="difficulty"], input[name="direction"]').forEach(radio => {
    radio.addEventListener('change', ()=>{
      refreshStreakUI();
      destroyPrefetch();
      hidePlot();
      hideExplanation();
      document.getElementById('nextBtn').style.display='none';
      showFeedback('Settings changed. Generating a warm-up problem…');
      const diff=getDifficulty(), dir=getDirection();
      schedulePrefetchFor(diff, dir);
    });
  });

  // --- flows ---
  function generateProblem(){
    const diff=getDifficulty(), dir=getDirection();
    if(!diff||!dir) return showFeedback('Please choose a direction and difficulty first.');
    req("{{ url_for('training_fourier.generate_problem') }}", {difficulty:diff, direction:dir})
     .then(data=>{ data._difficulty=diff; data._direction=dir; data._signature=signatureFor(diff,dir); renderProblemFromData(data, diff, dir); })
     .catch(()=>showFeedback('Error generating problem.'));
  }
  function onNextProblemClick(){
    const diff=getDifficulty(), dir=getDirection();
    const sig=signatureFor(diff,dir);
    const warmed=consumeCachedProblem(sig);
    if(warmed){ renderProblemFromData(warmed, warmed._difficulty, warmed._direction); prefetchNextProblem(); return; }
    if(prefetchPromise && prefetchTargetSignature===sig){
      const waitPromise=prefetchPromise; pendingWarmRequest={sig, diff, dir, from:'next'};
      waitPromise.then(()=>{
        if(!pendingWarmRequest || pendingWarmRequest.sig!==sig) return;
        pendingWarmRequest=null;
        const warmAgain=consumeCachedProblem(sig);
        if(warmAgain){ renderProblemFromData(warmAgain, warmAgain._difficulty, warmAgain._direction); prefetchNextProblem(); }
        else { destroyPrefetch(false); generateProblem(); }
      }).catch(()=>{
        if(!pendingWarmRequest || pendingWarmRequest.sig!==sig) return;
        pendingWarmRequest=null;
        destroyPrefetch(false); generateProblem();
      });
      showFeedback('Preparing next problem…');
      return;
    }
    destroyPrefetch();
    generateProblem();
  }
  function checkAnswer(selected){
    if (correctIndex===null) return showFeedback('Generate a problem first!');
    req("{{ url_for('training_fourier.check_answer') }}", {selectedIndex: selected, correctIndex: correctIndex})
    .then(data=>{
      document.querySelectorAll('.option-btn').forEach(b=>b.disabled=true);
      const overlay=document.getElementById('plotOverlay'); const hits=overlay.querySelectorAll('.plot-hit');
      hits.forEach(h=>h.style.pointerEvents='none');
      hits[correctIndex].classList.add('correct');
      if (selected!==correctIndex){ hits[selected].classList.add('incorrect'); 
        const btnSel=document.querySelector(`.option-btn[data-index="${selected}"]`); if(btnSel) btnSel.classList.add('incorrect'); }
      const btnCor=document.querySelector(`.option-btn[data-index="${correctIndex}"]`); if(btnCor) btnCor.classList.add('correct');
      showFeedback(data.feedback||''); const ok=(selected===correctIndex); bumpStreak(ok); showExplanation();
      if(!answeredThisRound){ answeredThisRound=true; prefetchNextProblem(); }
    })
    .catch(()=>showFeedback('Error checking answer.'));
  }

  // --- Prefetch ---
  function prefetchNextProblem(){
    const diff=getDifficulty(), dir=getDirection();
    schedulePrefetchFor(diff, dir);
  }
  function schedulePrefetchFor(diff, dir){
    if(!diff||!dir) return;
    const sig=signatureFor(diff, dir);
    if(cachedProblem && cachedSignature===sig) return;
    if(prefetchInFlight){
      if(prefetchTargetSignature===sig) return;
      if(prefetchCtrl){ try{prefetchCtrl.abort();}catch(_){}}
    }
    cachedProblem=null; cachedSignature=null;
    prefetchCtrl=new AbortController();
    prefetchInFlight=true;
    prefetchTargetSignature=sig;
    const promise=req("{{ url_for('training_fourier.generate_problem') }}", {difficulty:diff, direction:dir}, prefetchCtrl.signal)
      .then(data=>{
        if(!data) return;
        data._difficulty=diff; data._direction=dir; data._signature=sig;
        if(signatureFor(getDifficulty(), getDirection())===sig){
          cachedProblem=data; cachedSignature=sig;
        } else {
          cachedProblem=null; cachedSignature=null;
        }
      })
      .catch(()=>{})
      .finally(()=>{
        if(prefetchTargetSignature===sig){
          prefetchInFlight=false;
          prefetchCtrl=null;
          prefetchTargetSignature=null;
          prefetchPromise=null;
        }
      });
    prefetchPromise=promise;
  }
  function consumeCachedProblem(sig){
    if(cachedProblem && cachedSignature===sig){
      const warmed=cachedProblem;
      cachedProblem=null;
      cachedSignature=null;
      return warmed;
    }
    return null;
  }
  function destroyPrefetch(abort=true){
    if(abort && prefetchCtrl){ try{prefetchCtrl.abort();}catch(_){}}
    prefetchCtrl=null;
    prefetchInFlight=false;
    prefetchTargetSignature=null;
    prefetchPromise=null;
    pendingWarmRequest=null;
    cachedProblem=null;
    cachedSignature=null;
  }

  // --- streak ---
  function streakKey(s){return `fourier:streak:${s}`;} function bestKey(s){return `fourier:best:${s}`;}
  function readInt(k){ const v=localStorage.getItem(k); return v?parseInt(v,10):0; }
  function writeInt(k,v){ localStorage.setItem(k, String(v)); }
  function getStreak(s){return readInt(streakKey(s));} function setStreak(s,v){writeInt(streakKey(s),v);} function getBest(s){return readInt(bestKey(s));} function setBest(s,v){writeInt(bestKey(s),v);}
  function refreshStreakUI(){ const d=getDifficulty(), g=getDirection(); if(!d||!g) return; const s=signatureFor(d,g); document.getElementById('streakCur').textContent=getStreak(s); document.getElementById('streakBest').textContent=getBest(s); }
  function bumpStreak(ok){ const s=currentProblemSignature || signatureFor(getDifficulty(),getDirection()); if(!s) return; if(ok){ const cur=getStreak(s)+1; setStreak(s,cur); if(cur>getBest(s)) setBest(s,cur); flashStreak(); } else { setStreak(s,0);} refreshStreakUI(); }
  function flashStreak(){ const el=document.getElementById('streakPanel'); el.style.transition='transform .2s ease'; el.style.transform='scale(1.05)'; setTimeout(()=>{ el.style.transform='scale(1)'; }, 200); }
  document.getElementById('streakReset').addEventListener('click', ()=>{ const d=getDifficulty(), g=getDirection(); if(!d||!g) return; const s=signatureFor(d,g); setStreak(s,0); refreshStreakUI(); });

  schedulePrefetchFor(getDifficulty(), getDirection());
  refreshStreakUI();
</script>

  <style>
    .radio-group { display: flex; gap: 15px; }
    .radio-label { font-size: 1em; }
    .radio-label input { margin-right: 6px; }
    .action-btn { padding: 9px 18px; background-color: #007acc; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; text-decoration: none; }
    .action-btn:hover { background-color: #005fa3; }
    .option-btn.correct { background-color: #28a745; }
    .option-btn.incorrect { background-color: #c0392b; }
    .plot-wrap { position: relative; display: inline-block; }
    .plot-overlay { position: absolute; inset: 0; pointer-events: none; }
    .plot-hit { position: absolute; border: 2px solid transparent; border-radius: 8px; box-shadow: 0 0 0 0 rgba(0,0,0,0); transition: box-shadow 0.12s ease, border-color 0.12s ease; pointer-events: auto; cursor: pointer; box-sizing: border-box; }
    .plot-hit:hover { box-shadow: 0 0 0 2px rgba(0,122,204,0.28); }
    .plot-hit.correct { border-color: #28a745; box-shadow: 0 0 0 2px rgba(40,167,69,0.5); }
    .plot-hit.incorrect { border-color: #c0392b; box-shadow: 0 0 0 2px rgba(192,57,43,0.5); }
    .feedback { min-height: 1.4em; margin-top: 6px; }
    .explanation-card p { line-height: 1.5; }
  </style>
{% endblock %}
